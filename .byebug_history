quit
Dir[Dir.pwd + "/lib/qpush/jobs/*.rb"]
Dir[Dir.pwd + "/lib/jobs/*.rb"]
Dir.pwd
File.dirname(__FILE__)
Dir["#{File.dirname(__FILE__)}/qpush/jobs/*.rb"]
Dir[File.join(QPush.config.jobs_path, "*.rb")]
$LOAD_PATH.unshift(QPush.config.jobs_path)
$LOAD_PATH
File.dirname(__FILE__)
Dir[File.dirname(__FILE__) + "#{QPush.config.jobs_path}/*.rb"]
QPush.config.jobs_path
Dir["#{QPush.config.jobs_path}/*.rb"]
quit
puts e
puts s
c
puts e
puts s
s
jobs.compact!
jobs.compact![s, e]
jobs
quit
jobs
c
jobs
quit
job_hash
quit
delayed_jobs
delay_jobs
c
conn.zrange(QPush.config.delay_namespace, 0, -1, with_scores: true)
delayed_jobs
quit
conn.get("#{@namespace}:#{stat}")
"#{@namespace}:#{stat}"
c
name
c
self.name
quit
job
delays.each { |job| PerformJob.call(Job.new(job)) }
cccccccccccc
elcccccccccccccccccccc
delaysdelays.each {|job| PerformJob.call(Job.new(job))}
quit
Server.connection_pool
Qued::QPush.redis
QPush.redis
c
QueueJob.new(job).call
job.valid? && job.queueable?
job.valid?
return false unless job.valid? && job.queueable?
job
quit
@start_at < Time.now.to_i && !@cron.empty?
@start_at > Time.now.to_i && @cron.empty?
@start_at < Time.now.to_i && @cron.empty?
QueueJob.new(self).call
quit
job.valid?
job.save
test
quit
job.save
job
job = Job.new(options)
options
quit
cron?
delay?
queue?
quit
c
job_type.call
quit
job_type.call
quit
performer
performer = retrieve_job_type
quit
self
performer.call
performer
performer = retrieve_job_type
performer.call
performer
retrieve_job_type
performer
c
quit
performer.call
performer
performer = retrieve_job_type
valid?
c
@job.queue?
@job.delay?
@job.cron?
@job
job_success
measure_run_time { @job.run }
@job.run
c
quit
log_success
job_success && log_success
c
@job.run
@job = Job.new(JSON.parse(json))
c
@job = Job.new(JSON.parse(json))
json
quit
json
son
