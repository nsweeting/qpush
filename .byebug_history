c
job.valid?
job.setup
job
c
json
c
self.config
config
Server.config
c
Server.config
c
QPush::Server.config
c
QPush::Server.config
c
job.perform
job = Job.new(JSON.parse(json))
json
c
delays.count
delays.any?
delays
@conn
c
valid?
c
configs
c
configs
c
valid?
config
c
valid?
@configs
configs
c
configs ? true : false
configs
c
valid?
quit
job.klass
job.errors
job.valid?
c
jobs
c
request.path_info
c
hash
c
@jobs.compact[@start, @count]
@jobs.compact
@jobs.compact!
@count
@start
@jobs
c
@count
@start
@jobs
c
 Delay.call(@job, :delay)
c
Delay.call(@job)
c
@stats.each_key { |key| puts key }
@stats.each_key { |key| @stats[key].to_i }
@stats
c
@stats
c
quit
Perform.call(@job)
c
Perform.call(@job)
c
@job
invalid_job && return unless @job.valid?
c
job
c
@fails = @fails.compact[@start, @count]
@fails
@Fails
@fails.compact!
@fails.compact![@start..@count]
@fails.compact![@start, @count]
@fails.any?
@count
@start
@fails
c
@fails
c
@fails
c
percent
quit
y
q
(100.00 - ((stats[:failed].to_f / stats[:performed].to_f) * 100.00)).round(2)
100.00 - ((stats[:failed].to_f / stats[:performed].to_f) * 100.00)
stats[:failed].to_f / stats[:performed].to_f
stats[:failed].to_f
stats[:failed].to_i / stats[:performed].to_i
(stats[:failed] / stats[:performed])
stats[:performed]
stats[:failed]
percent
c
conn.lrange("#{QPush.config.perform_namespace}:last_10", 0, 10)
c
json
c
conn.get("#{namespace}:#{s}")
stats
c
nil.to_i
stats
quit
Dir[Dir.pwd + "/lib/qpush/jobs/*.rb"]
Dir[Dir.pwd + "/lib/jobs/*.rb"]
Dir.pwd
File.dirname(__FILE__)
Dir["#{File.dirname(__FILE__)}/qpush/jobs/*.rb"]
Dir[File.join(QPush.config.jobs_path, "*.rb")]
$LOAD_PATH.unshift(QPush.config.jobs_path)
$LOAD_PATH
File.dirname(__FILE__)
Dir[File.dirname(__FILE__) + "#{QPush.config.jobs_path}/*.rb"]
QPush.config.jobs_path
Dir["#{QPush.config.jobs_path}/*.rb"]
quit
puts e
puts s
c
puts e
puts s
s
jobs.compact!
jobs.compact![s, e]
jobs
quit
jobs
c
jobs
quit
job_hash
quit
delayed_jobs
delay_jobs
c
conn.zrange(QPush.config.delay_namespace, 0, -1, with_scores: true)
delayed_jobs
quit
conn.get("#{@namespace}:#{stat}")
"#{@namespace}:#{stat}"
c
name
c
self.name
quit
job
delays.each { |job| PerformJob.call(Job.new(job)) }
cccccccccccc
elcccccccccccccccccccc
delaysdelays.each {|job| PerformJob.call(Job.new(job))}
quit
Server.connection_pool
Qued::QPush.redis
QPush.redis
c
QueueJob.new(job).call
job.valid? && job.queueable?
job.valid?
return false unless job.valid? && job.queueable?
job
quit
@start_at < Time.now.to_i && !@cron.empty?
@start_at > Time.now.to_i && @cron.empty?
@start_at < Time.now.to_i && @cron.empty?
QueueJob.new(self).call
quit
job.valid?
job.save
test
quit
job.save
job
job = Job.new(options)
options
quit
cron?
delay?
queue?
quit
c
job_type.call
quit
job_type.call
quit
performer
performer = retrieve_job_type
quit
self
performer.call
performer
performer = retrieve_job_type
performer.call
performer
retrieve_job_type
performer
c
quit
performer.call
performer
performer = retrieve_job_type
valid?
c
@job.queue?
@job.delay?
@job.cron?
@job
job_success
measure_run_time { @job.run }
@job.run
c
quit
log_success
job_success && log_success
c
@job.run
@job = Job.new(JSON.parse(json))
c
@job = Job.new(JSON.parse(json))
json
quit
json
son
